//
//  PalitraStyleKit.swift
//  Palitra
//
//  Created by Martin Velchevski on 27.07.17.
//  Copyright Â© 2017 martincodes. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import Cocoa

public class PalitraStyleKit : NSObject {

    //// Cache

    private struct Cache {
        static let paleWhite: NSColor = NSColor(red: 0.98, green: 0.98, blue: 0.98, alpha: 1)
        static let lightGrey: NSColor = NSColor(red: 0.85, green: 0.85, blue: 0.85, alpha: 1)
        static let dark: NSColor = NSColor(red: 0, green: 0, blue: 0, alpha: 1)
    }

    //// Colors

    @objc dynamic public class var paleWhite: NSColor { return Cache.paleWhite }
    @objc dynamic public class var lightGrey: NSColor { return Cache.lightGrey }
    @objc dynamic public class var dark: NSColor { return Cache.dark }

    //// Drawing Methods

    @objc dynamic public class func drawPalitraNewButton(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let group: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 12, height: 12)


        //// Rectangle Drawing
        let rectanglePath = NSBezierPath(roundedRect: NSRect(x: frame.minX + fastFloor(frame.width * 0.02083) + 0.5, y: frame.minY + fastFloor(frame.height * 0.02083) + 0.5, width: fastFloor(frame.width * 0.97917) - fastFloor(frame.width * 0.02083), height: fastFloor(frame.height * 0.97917) - fastFloor(frame.height * 0.02083)), xRadius: 4, yRadius: 4)
        NSColor.black.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()


        //// Group
        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: group.minX + 6, y: group.minY + 3))
        bezierPath.curve(to: NSPoint(x: group.minX + 7, y: group.minY + 2), controlPoint1: NSPoint(x: group.minX + 6, y: group.minY + 2.45), controlPoint2: NSPoint(x: group.minX + 6.45, y: group.minY + 2))
        bezierPath.line(to: NSPoint(x: group.minX + 8, y: group.minY + 2))
        bezierPath.line(to: NSPoint(x: group.minX + 8, y: group.minY + 1))
        bezierPath.curve(to: NSPoint(x: group.minX + 9, y: group.minY), controlPoint1: NSPoint(x: group.minX + 8, y: group.minY + 0.45), controlPoint2: NSPoint(x: group.minX + 8.45, y: group.minY))
        bezierPath.curve(to: NSPoint(x: group.minX + 10, y: group.minY + 1), controlPoint1: NSPoint(x: group.minX + 9.55, y: group.minY), controlPoint2: NSPoint(x: group.minX + 10, y: group.minY + 0.45))
        bezierPath.line(to: NSPoint(x: group.minX + 10, y: group.minY + 2))
        bezierPath.line(to: NSPoint(x: group.minX + 11, y: group.minY + 2))
        bezierPath.curve(to: NSPoint(x: group.minX + 11.71, y: group.minY + 2.29), controlPoint1: NSPoint(x: group.minX + 11.27, y: group.minY + 2), controlPoint2: NSPoint(x: group.minX + 11.52, y: group.minY + 2.11))
        bezierPath.curve(to: NSPoint(x: group.minX + 12, y: group.minY + 3), controlPoint1: NSPoint(x: group.minX + 11.89, y: group.minY + 2.48), controlPoint2: NSPoint(x: group.minX + 12, y: group.minY + 2.73))
        bezierPath.curve(to: NSPoint(x: group.minX + 11, y: group.minY + 4), controlPoint1: NSPoint(x: group.minX + 12, y: group.minY + 3.55), controlPoint2: NSPoint(x: group.minX + 11.55, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 10, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 10, y: group.minY + 5))
        bezierPath.curve(to: NSPoint(x: group.minX + 9, y: group.minY + 6), controlPoint1: NSPoint(x: group.minX + 10, y: group.minY + 5.55), controlPoint2: NSPoint(x: group.minX + 9.55, y: group.minY + 6))
        bezierPath.curve(to: NSPoint(x: group.minX + 8, y: group.minY + 5), controlPoint1: NSPoint(x: group.minX + 8.45, y: group.minY + 6), controlPoint2: NSPoint(x: group.minX + 8, y: group.minY + 5.55))
        bezierPath.line(to: NSPoint(x: group.minX + 8, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 7, y: group.minY + 4))
        bezierPath.curve(to: NSPoint(x: group.minX + 6, y: group.minY + 3), controlPoint1: NSPoint(x: group.minX + 6.45, y: group.minY + 4), controlPoint2: NSPoint(x: group.minX + 6, y: group.minY + 3.55))
        bezierPath.line(to: NSPoint(x: group.minX + 6, y: group.minY + 3))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        PalitraStyleKit.dark.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = NSBezierPath()
        bezier2Path.move(to: NSPoint(x: group.minX + 7.68, y: group.minY + 6.5))
        bezier2Path.curve(to: NSPoint(x: group.minX + 8, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX + 7.88, y: group.minY + 7.07), controlPoint2: NSPoint(x: group.minX + 8, y: group.minY + 7.58))
        bezier2Path.curve(to: NSPoint(x: group.minX + 4, y: group.minY + 12), controlPoint1: NSPoint(x: group.minX + 8, y: group.minY + 10.21), controlPoint2: NSPoint(x: group.minX + 6.21, y: group.minY + 12))
        bezier2Path.curve(to: NSPoint(x: group.minX, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX + 1.79, y: group.minY + 12), controlPoint2: NSPoint(x: group.minX, y: group.minY + 10.21))
        bezier2Path.curve(to: NSPoint(x: group.minX + 4, y: group.minY), controlPoint1: NSPoint(x: group.minX, y: group.minY + 5.6), controlPoint2: NSPoint(x: group.minX + 4, y: group.minY))
        bezier2Path.curve(to: NSPoint(x: group.minX + 5.3, y: group.minY + 1.95), controlPoint1: NSPoint(x: group.minX + 4, y: group.minY), controlPoint2: NSPoint(x: group.minX + 4.58, y: group.minY + 0.81))
        bezier2Path.curve(to: NSPoint(x: group.minX + 5.2, y: group.minY + 2.13), controlPoint1: NSPoint(x: group.minX + 5.26, y: group.minY + 2.01), controlPoint2: NSPoint(x: group.minX + 5.23, y: group.minY + 2.07))
        bezier2Path.curve(to: NSPoint(x: group.minX + 5.09, y: group.minY + 3.59), controlPoint1: NSPoint(x: group.minX + 4.98, y: group.minY + 2.59), controlPoint2: NSPoint(x: group.minX + 4.94, y: group.minY + 3.11))
        bezier2Path.curve(to: NSPoint(x: group.minX + 5.4, y: group.minY + 4.2), controlPoint1: NSPoint(x: group.minX + 5.16, y: group.minY + 3.81), controlPoint2: NSPoint(x: group.minX + 5.26, y: group.minY + 4.02))
        bezier2Path.curve(to: NSPoint(x: group.minX + 5.96, y: group.minY + 4.71), controlPoint1: NSPoint(x: group.minX + 5.55, y: group.minY + 4.4), controlPoint2: NSPoint(x: group.minX + 5.74, y: group.minY + 4.58))
        bezier2Path.curve(to: NSPoint(x: group.minX + 6.5, y: group.minY + 4.94), controlPoint1: NSPoint(x: group.minX + 6.13, y: group.minY + 4.81), controlPoint2: NSPoint(x: group.minX + 6.31, y: group.minY + 4.89))
        bezier2Path.curve(to: NSPoint(x: group.minX + 6.8, y: group.minY + 4.99), controlPoint1: NSPoint(x: group.minX + 6.6, y: group.minY + 4.96), controlPoint2: NSPoint(x: group.minX + 6.7, y: group.minY + 4.98))
        bezier2Path.line(to: NSPoint(x: group.minX + 6.9, y: group.minY + 5))
        bezier2Path.curve(to: NSPoint(x: group.minX + 7, y: group.minY + 5), controlPoint1: NSPoint(x: group.minX + 6.93, y: group.minY + 5), controlPoint2: NSPoint(x: group.minX + 6.97, y: group.minY + 5))
        bezier2Path.line(to: NSPoint(x: group.minX + 7, y: group.minY + 5.01))
        bezier2Path.curve(to: NSPoint(x: group.minX + 7.02, y: group.minY + 5.3), controlPoint1: NSPoint(x: group.minX + 7, y: group.minY + 5.11), controlPoint2: NSPoint(x: group.minX + 7.01, y: group.minY + 5.21))
        bezier2Path.curve(to: NSPoint(x: group.minX + 7.24, y: group.minY + 5.95), controlPoint1: NSPoint(x: group.minX + 7.06, y: group.minY + 5.53), controlPoint2: NSPoint(x: group.minX + 7.13, y: group.minY + 5.75))
        bezier2Path.curve(to: NSPoint(x: group.minX + 7.68, y: group.minY + 6.5), controlPoint1: NSPoint(x: group.minX + 7.35, y: group.minY + 6.16), controlPoint2: NSPoint(x: group.minX + 7.5, y: group.minY + 6.35))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 2, y: group.minY + 10))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 10))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 10))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 1, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 1, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 1, y: group.minY + 9))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 4, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 4, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 7))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezier2Path.line(to: NSPoint(x: group.minX + 4, y: group.minY + 7))
        bezier2Path.line(to: NSPoint(x: group.minX + 4, y: group.minY + 6))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 6))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezier2Path.close()
        bezier2Path.windingRule = .evenOddWindingRule
        PalitraStyleKit.dark.setFill()
        bezier2Path.fill()
    }

    @objc dynamic public class func drawPalitraRandomizeButton(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let group: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 12, height: 12)


        //// Rectangle Drawing
        let rectanglePath = NSBezierPath(roundedRect: NSRect(x: frame.minX + fastFloor(frame.width * 0.02083) + 0.5, y: frame.minY + 0.5, width: fastFloor(frame.width * 0.97917) - fastFloor(frame.width * 0.02083), height: fastFloor((frame.height - 0.5) * 0.97872 + 0.5)), xRadius: 4, yRadius: 4)
        NSColor.black.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()


        //// Group
        //// shape Drawing
        let shapePath = NSBezierPath()
        shapePath.move(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        shapePath.curve(to: NSPoint(x: group.minX + 4, y: group.minY + 10), controlPoint1: NSPoint(x: group.minX + 3.1, y: group.minY + 8), controlPoint2: NSPoint(x: group.minX + 4, y: group.minY + 8.9))
        shapePath.curve(to: NSPoint(x: group.minX + 2, y: group.minY + 12), controlPoint1: NSPoint(x: group.minX + 4, y: group.minY + 11.1), controlPoint2: NSPoint(x: group.minX + 3.1, y: group.minY + 12))
        shapePath.curve(to: NSPoint(x: group.minX, y: group.minY + 10), controlPoint1: NSPoint(x: group.minX + 0.9, y: group.minY + 12), controlPoint2: NSPoint(x: group.minX, y: group.minY + 11.1))
        shapePath.curve(to: NSPoint(x: group.minX + 2, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX, y: group.minY + 8.9), controlPoint2: NSPoint(x: group.minX + 0.9, y: group.minY + 8))
        shapePath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        shapePath.close()
        shapePath.move(to: NSPoint(x: group.minX + 1, y: group.minY + 10))
        shapePath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 10))
        shapePath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 9))
        shapePath.line(to: NSPoint(x: group.minX + 1, y: group.minY + 9))
        shapePath.line(to: NSPoint(x: group.minX + 1, y: group.minY + 10))
        shapePath.close()
        shapePath.move(to: NSPoint(x: group.minX + 6, y: group.minY + 4))
        shapePath.curve(to: NSPoint(x: group.minX + 8, y: group.minY + 6), controlPoint1: NSPoint(x: group.minX + 7.1, y: group.minY + 4), controlPoint2: NSPoint(x: group.minX + 8, y: group.minY + 4.9))
        shapePath.curve(to: NSPoint(x: group.minX + 6, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX + 8, y: group.minY + 7.1), controlPoint2: NSPoint(x: group.minX + 7.1, y: group.minY + 8))
        shapePath.curve(to: NSPoint(x: group.minX + 4, y: group.minY + 6), controlPoint1: NSPoint(x: group.minX + 4.9, y: group.minY + 8), controlPoint2: NSPoint(x: group.minX + 4, y: group.minY + 7.1))
        shapePath.curve(to: NSPoint(x: group.minX + 6, y: group.minY + 4), controlPoint1: NSPoint(x: group.minX + 4, y: group.minY + 4.9), controlPoint2: NSPoint(x: group.minX + 4.9, y: group.minY + 4))
        shapePath.line(to: NSPoint(x: group.minX + 6, y: group.minY + 4))
        shapePath.close()
        shapePath.move(to: NSPoint(x: group.minX + 5, y: group.minY + 6))
        shapePath.line(to: NSPoint(x: group.minX + 6, y: group.minY + 6))
        shapePath.line(to: NSPoint(x: group.minX + 6, y: group.minY + 5))
        shapePath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 5))
        shapePath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 6))
        shapePath.close()
        shapePath.move(to: NSPoint(x: group.minX + 10, y: group.minY))
        shapePath.curve(to: NSPoint(x: group.minX + 12, y: group.minY + 2), controlPoint1: NSPoint(x: group.minX + 11.1, y: group.minY), controlPoint2: NSPoint(x: group.minX + 12, y: group.minY + 0.9))
        shapePath.curve(to: NSPoint(x: group.minX + 10, y: group.minY + 4), controlPoint1: NSPoint(x: group.minX + 12, y: group.minY + 3.1), controlPoint2: NSPoint(x: group.minX + 11.1, y: group.minY + 4))
        shapePath.curve(to: NSPoint(x: group.minX + 8, y: group.minY + 2), controlPoint1: NSPoint(x: group.minX + 8.9, y: group.minY + 4), controlPoint2: NSPoint(x: group.minX + 8, y: group.minY + 3.1))
        shapePath.curve(to: NSPoint(x: group.minX + 10, y: group.minY), controlPoint1: NSPoint(x: group.minX + 8, y: group.minY + 0.9), controlPoint2: NSPoint(x: group.minX + 8.9, y: group.minY))
        shapePath.line(to: NSPoint(x: group.minX + 10, y: group.minY))
        shapePath.close()
        shapePath.move(to: NSPoint(x: group.minX + 9, y: group.minY + 2))
        shapePath.line(to: NSPoint(x: group.minX + 10, y: group.minY + 2))
        shapePath.line(to: NSPoint(x: group.minX + 10, y: group.minY + 1))
        shapePath.line(to: NSPoint(x: group.minX + 9, y: group.minY + 1))
        shapePath.line(to: NSPoint(x: group.minX + 9, y: group.minY + 2))
        shapePath.close()
        shapePath.windingRule = .evenOddWindingRule
        PalitraStyleKit.dark.setFill()
        shapePath.fill()
    }

    @objc dynamic public class func drawPalitraSketchSyncButton(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let group: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 12, height: 12)


        //// Rectangle Drawing
        let rectanglePath = NSBezierPath(roundedRect: NSRect(x: frame.minX + fastFloor(frame.width * 0.02083) + 0.5, y: frame.minY + 0.5, width: fastFloor(frame.width * 0.97917) - fastFloor(frame.width * 0.02083), height: fastFloor((frame.height - 0.5) * 0.97872 + 0.5)), xRadius: 4, yRadius: 4)
        NSColor.black.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()


        //// Group
        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: group.minX + 2, y: group.minY))
        bezierPath.line(to: NSPoint(x: group.minX + 10, y: group.minY))
        bezierPath.line(to: NSPoint(x: group.minX + 12, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 12, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 6, y: group.minY + 12))
        bezierPath.line(to: NSPoint(x: group.minX, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 4, y: group.minY + 6))
        bezierPath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 6))
        bezierPath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 5))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 5))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 6))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 3, y: group.minY + 5))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 5))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 5))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 2, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 4))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 4, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 4))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 3, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 2))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 2))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 3))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        PalitraStyleKit.dark.setFill()
        bezierPath.fill()
    }

    @objc dynamic public class func drawSketchIcon(frame: NSRect = NSRect(x: 0, y: 0, width: 12, height: 12)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let icon: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) / 2 + 0.5), y: frame.minY + fastFloor((frame.height - 12) / 2 + 0.5), width: 12, height: 12)


        //// icon
        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: icon.minX + 2, y: icon.minY + 12))
        bezierPath.line(to: NSPoint(x: icon.minX + 10, y: icon.minY + 12))
        bezierPath.line(to: NSPoint(x: icon.minX + 12, y: icon.minY + 9))
        bezierPath.line(to: NSPoint(x: icon.minX + 12, y: icon.minY + 8))
        bezierPath.line(to: NSPoint(x: icon.minX + 6, y: icon.minY))
        bezierPath.line(to: NSPoint(x: icon.minX, y: icon.minY + 8))
        bezierPath.line(to: NSPoint(x: icon.minX, y: icon.minY + 9))
        bezierPath.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 12))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: icon.minX + 4, y: icon.minY + 6))
        bezierPath.line(to: NSPoint(x: icon.minX + 5, y: icon.minY + 6))
        bezierPath.line(to: NSPoint(x: icon.minX + 5, y: icon.minY + 7))
        bezierPath.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 7))
        bezierPath.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 6))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: icon.minX + 3, y: icon.minY + 7))
        bezierPath.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 7))
        bezierPath.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 8))
        bezierPath.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 8))
        bezierPath.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 7))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: icon.minX + 2, y: icon.minY + 8))
        bezierPath.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 8))
        bezierPath.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 9))
        bezierPath.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 9))
        bezierPath.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 8))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: icon.minX + 4, y: icon.minY + 8))
        bezierPath.line(to: NSPoint(x: icon.minX + 5, y: icon.minY + 8))
        bezierPath.line(to: NSPoint(x: icon.minX + 5, y: icon.minY + 9))
        bezierPath.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 9))
        bezierPath.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 8))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: icon.minX + 3, y: icon.minY + 9))
        bezierPath.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 9))
        bezierPath.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 10))
        bezierPath.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 10))
        bezierPath.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 9))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        PalitraStyleKit.dark.setFill()
        bezierPath.fill()
    }

    @objc dynamic public class func drawRandomizeIcon(frame: NSRect = NSRect(x: 0, y: 0, width: 12, height: 12)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let icon: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) / 2 + 0.5), y: frame.minY + fastFloor((frame.height - 12) / 2 + 0.5), width: 12, height: 12)


        //// icon
        //// shape Drawing
        let shapePath = NSBezierPath()
        shapePath.move(to: NSPoint(x: icon.minX + 2, y: icon.minY + 4))
        shapePath.curve(to: NSPoint(x: icon.minX + 4, y: icon.minY + 2), controlPoint1: NSPoint(x: icon.minX + 3.1, y: icon.minY + 4), controlPoint2: NSPoint(x: icon.minX + 4, y: icon.minY + 3.1))
        shapePath.curve(to: NSPoint(x: icon.minX + 2, y: icon.minY), controlPoint1: NSPoint(x: icon.minX + 4, y: icon.minY + 0.9), controlPoint2: NSPoint(x: icon.minX + 3.1, y: icon.minY))
        shapePath.curve(to: NSPoint(x: icon.minX, y: icon.minY + 2), controlPoint1: NSPoint(x: icon.minX + 0.9, y: icon.minY), controlPoint2: NSPoint(x: icon.minX, y: icon.minY + 0.9))
        shapePath.curve(to: NSPoint(x: icon.minX + 2, y: icon.minY + 4), controlPoint1: NSPoint(x: icon.minX, y: icon.minY + 3.1), controlPoint2: NSPoint(x: icon.minX + 0.9, y: icon.minY + 4))
        shapePath.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 4))
        shapePath.close()
        shapePath.move(to: NSPoint(x: icon.minX + 1, y: icon.minY + 2))
        shapePath.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 2))
        shapePath.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 3))
        shapePath.line(to: NSPoint(x: icon.minX + 1, y: icon.minY + 3))
        shapePath.line(to: NSPoint(x: icon.minX + 1, y: icon.minY + 2))
        shapePath.close()
        shapePath.move(to: NSPoint(x: icon.minX + 6, y: icon.minY + 8))
        shapePath.curve(to: NSPoint(x: icon.minX + 8, y: icon.minY + 6), controlPoint1: NSPoint(x: icon.minX + 7.1, y: icon.minY + 8), controlPoint2: NSPoint(x: icon.minX + 8, y: icon.minY + 7.1))
        shapePath.curve(to: NSPoint(x: icon.minX + 6, y: icon.minY + 4), controlPoint1: NSPoint(x: icon.minX + 8, y: icon.minY + 4.9), controlPoint2: NSPoint(x: icon.minX + 7.1, y: icon.minY + 4))
        shapePath.curve(to: NSPoint(x: icon.minX + 4, y: icon.minY + 6), controlPoint1: NSPoint(x: icon.minX + 4.9, y: icon.minY + 4), controlPoint2: NSPoint(x: icon.minX + 4, y: icon.minY + 4.9))
        shapePath.curve(to: NSPoint(x: icon.minX + 6, y: icon.minY + 8), controlPoint1: NSPoint(x: icon.minX + 4, y: icon.minY + 7.1), controlPoint2: NSPoint(x: icon.minX + 4.9, y: icon.minY + 8))
        shapePath.line(to: NSPoint(x: icon.minX + 6, y: icon.minY + 8))
        shapePath.close()
        shapePath.move(to: NSPoint(x: icon.minX + 5, y: icon.minY + 6))
        shapePath.line(to: NSPoint(x: icon.minX + 6, y: icon.minY + 6))
        shapePath.line(to: NSPoint(x: icon.minX + 6, y: icon.minY + 7))
        shapePath.line(to: NSPoint(x: icon.minX + 5, y: icon.minY + 7))
        shapePath.line(to: NSPoint(x: icon.minX + 5, y: icon.minY + 6))
        shapePath.close()
        shapePath.move(to: NSPoint(x: icon.minX + 10, y: icon.minY + 12))
        shapePath.curve(to: NSPoint(x: icon.minX + 12, y: icon.minY + 10), controlPoint1: NSPoint(x: icon.minX + 11.1, y: icon.minY + 12), controlPoint2: NSPoint(x: icon.minX + 12, y: icon.minY + 11.1))
        shapePath.curve(to: NSPoint(x: icon.minX + 10, y: icon.minY + 8), controlPoint1: NSPoint(x: icon.minX + 12, y: icon.minY + 8.9), controlPoint2: NSPoint(x: icon.minX + 11.1, y: icon.minY + 8))
        shapePath.curve(to: NSPoint(x: icon.minX + 8, y: icon.minY + 10), controlPoint1: NSPoint(x: icon.minX + 8.9, y: icon.minY + 8), controlPoint2: NSPoint(x: icon.minX + 8, y: icon.minY + 8.9))
        shapePath.curve(to: NSPoint(x: icon.minX + 10, y: icon.minY + 12), controlPoint1: NSPoint(x: icon.minX + 8, y: icon.minY + 11.1), controlPoint2: NSPoint(x: icon.minX + 8.9, y: icon.minY + 12))
        shapePath.line(to: NSPoint(x: icon.minX + 10, y: icon.minY + 12))
        shapePath.close()
        shapePath.move(to: NSPoint(x: icon.minX + 9, y: icon.minY + 10))
        shapePath.line(to: NSPoint(x: icon.minX + 10, y: icon.minY + 10))
        shapePath.line(to: NSPoint(x: icon.minX + 10, y: icon.minY + 11))
        shapePath.line(to: NSPoint(x: icon.minX + 9, y: icon.minY + 11))
        shapePath.line(to: NSPoint(x: icon.minX + 9, y: icon.minY + 10))
        shapePath.close()
        shapePath.windingRule = .evenOddWindingRule
        PalitraStyleKit.dark.setFill()
        shapePath.fill()
    }

    @objc dynamic public class func drawPaletteIcon(frame: NSRect = NSRect(x: 0, y: 0, width: 12, height: 12)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let icon: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) / 2 + 0.5), y: frame.minY + fastFloor((frame.height - 12) / 2 + 0.5), width: 12, height: 12)


        //// icon
        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: icon.minX + 6, y: icon.minY + 9))
        bezierPath.curve(to: NSPoint(x: icon.minX + 7, y: icon.minY + 10), controlPoint1: NSPoint(x: icon.minX + 6, y: icon.minY + 9.55), controlPoint2: NSPoint(x: icon.minX + 6.45, y: icon.minY + 10))
        bezierPath.line(to: NSPoint(x: icon.minX + 8, y: icon.minY + 10))
        bezierPath.line(to: NSPoint(x: icon.minX + 8, y: icon.minY + 11))
        bezierPath.curve(to: NSPoint(x: icon.minX + 9, y: icon.minY + 12), controlPoint1: NSPoint(x: icon.minX + 8, y: icon.minY + 11.55), controlPoint2: NSPoint(x: icon.minX + 8.45, y: icon.minY + 12))
        bezierPath.curve(to: NSPoint(x: icon.minX + 10, y: icon.minY + 11), controlPoint1: NSPoint(x: icon.minX + 9.55, y: icon.minY + 12), controlPoint2: NSPoint(x: icon.minX + 10, y: icon.minY + 11.55))
        bezierPath.line(to: NSPoint(x: icon.minX + 10, y: icon.minY + 10))
        bezierPath.line(to: NSPoint(x: icon.minX + 11, y: icon.minY + 10))
        bezierPath.curve(to: NSPoint(x: icon.minX + 11.71, y: icon.minY + 9.71), controlPoint1: NSPoint(x: icon.minX + 11.27, y: icon.minY + 10), controlPoint2: NSPoint(x: icon.minX + 11.52, y: icon.minY + 9.89))
        bezierPath.curve(to: NSPoint(x: icon.minX + 12, y: icon.minY + 9), controlPoint1: NSPoint(x: icon.minX + 11.89, y: icon.minY + 9.52), controlPoint2: NSPoint(x: icon.minX + 12, y: icon.minY + 9.27))
        bezierPath.curve(to: NSPoint(x: icon.minX + 11, y: icon.minY + 8), controlPoint1: NSPoint(x: icon.minX + 12, y: icon.minY + 8.45), controlPoint2: NSPoint(x: icon.minX + 11.55, y: icon.minY + 8))
        bezierPath.line(to: NSPoint(x: icon.minX + 10, y: icon.minY + 8))
        bezierPath.line(to: NSPoint(x: icon.minX + 10, y: icon.minY + 7))
        bezierPath.curve(to: NSPoint(x: icon.minX + 9, y: icon.minY + 6), controlPoint1: NSPoint(x: icon.minX + 10, y: icon.minY + 6.45), controlPoint2: NSPoint(x: icon.minX + 9.55, y: icon.minY + 6))
        bezierPath.curve(to: NSPoint(x: icon.minX + 8, y: icon.minY + 7), controlPoint1: NSPoint(x: icon.minX + 8.45, y: icon.minY + 6), controlPoint2: NSPoint(x: icon.minX + 8, y: icon.minY + 6.45))
        bezierPath.line(to: NSPoint(x: icon.minX + 8, y: icon.minY + 8))
        bezierPath.line(to: NSPoint(x: icon.minX + 7, y: icon.minY + 8))
        bezierPath.curve(to: NSPoint(x: icon.minX + 6, y: icon.minY + 9), controlPoint1: NSPoint(x: icon.minX + 6.45, y: icon.minY + 8), controlPoint2: NSPoint(x: icon.minX + 6, y: icon.minY + 8.45))
        bezierPath.line(to: NSPoint(x: icon.minX + 6, y: icon.minY + 9))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        PalitraStyleKit.dark.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = NSBezierPath()
        bezier2Path.move(to: NSPoint(x: icon.minX + 7.68, y: icon.minY + 5.5))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 8, y: icon.minY + 4), controlPoint1: NSPoint(x: icon.minX + 7.88, y: icon.minY + 4.93), controlPoint2: NSPoint(x: icon.minX + 8, y: icon.minY + 4.42))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 4, y: icon.minY), controlPoint1: NSPoint(x: icon.minX + 8, y: icon.minY + 1.79), controlPoint2: NSPoint(x: icon.minX + 6.21, y: icon.minY))
        bezier2Path.curve(to: NSPoint(x: icon.minX, y: icon.minY + 4), controlPoint1: NSPoint(x: icon.minX + 1.79, y: icon.minY), controlPoint2: NSPoint(x: icon.minX, y: icon.minY + 1.79))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 4, y: icon.minY + 12), controlPoint1: NSPoint(x: icon.minX, y: icon.minY + 6.4), controlPoint2: NSPoint(x: icon.minX + 4, y: icon.minY + 12))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 5.3, y: icon.minY + 10.05), controlPoint1: NSPoint(x: icon.minX + 4, y: icon.minY + 12), controlPoint2: NSPoint(x: icon.minX + 4.58, y: icon.minY + 11.19))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 5.2, y: icon.minY + 9.87), controlPoint1: NSPoint(x: icon.minX + 5.26, y: icon.minY + 9.99), controlPoint2: NSPoint(x: icon.minX + 5.23, y: icon.minY + 9.93))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 5.09, y: icon.minY + 8.41), controlPoint1: NSPoint(x: icon.minX + 4.98, y: icon.minY + 9.41), controlPoint2: NSPoint(x: icon.minX + 4.94, y: icon.minY + 8.89))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 5.4, y: icon.minY + 7.8), controlPoint1: NSPoint(x: icon.minX + 5.16, y: icon.minY + 8.19), controlPoint2: NSPoint(x: icon.minX + 5.26, y: icon.minY + 7.98))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 5.96, y: icon.minY + 7.29), controlPoint1: NSPoint(x: icon.minX + 5.55, y: icon.minY + 7.6), controlPoint2: NSPoint(x: icon.minX + 5.74, y: icon.minY + 7.42))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 6.5, y: icon.minY + 7.06), controlPoint1: NSPoint(x: icon.minX + 6.13, y: icon.minY + 7.19), controlPoint2: NSPoint(x: icon.minX + 6.31, y: icon.minY + 7.11))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 6.8, y: icon.minY + 7.01), controlPoint1: NSPoint(x: icon.minX + 6.6, y: icon.minY + 7.04), controlPoint2: NSPoint(x: icon.minX + 6.7, y: icon.minY + 7.02))
        bezier2Path.line(to: NSPoint(x: icon.minX + 6.9, y: icon.minY + 7))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 7, y: icon.minY + 7), controlPoint1: NSPoint(x: icon.minX + 6.93, y: icon.minY + 7), controlPoint2: NSPoint(x: icon.minX + 6.97, y: icon.minY + 7))
        bezier2Path.line(to: NSPoint(x: icon.minX + 7, y: icon.minY + 6.99))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 7.02, y: icon.minY + 6.7), controlPoint1: NSPoint(x: icon.minX + 7, y: icon.minY + 6.89), controlPoint2: NSPoint(x: icon.minX + 7.01, y: icon.minY + 6.79))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 7.24, y: icon.minY + 6.05), controlPoint1: NSPoint(x: icon.minX + 7.06, y: icon.minY + 6.47), controlPoint2: NSPoint(x: icon.minX + 7.13, y: icon.minY + 6.25))
        bezier2Path.curve(to: NSPoint(x: icon.minX + 7.68, y: icon.minY + 5.5), controlPoint1: NSPoint(x: icon.minX + 7.35, y: icon.minY + 5.84), controlPoint2: NSPoint(x: icon.minX + 7.5, y: icon.minY + 5.65))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: icon.minX + 2, y: icon.minY + 2))
        bezier2Path.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 2))
        bezier2Path.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 3))
        bezier2Path.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 3))
        bezier2Path.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 2))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: icon.minX + 1, y: icon.minY + 3))
        bezier2Path.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 3))
        bezier2Path.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 4))
        bezier2Path.line(to: NSPoint(x: icon.minX + 1, y: icon.minY + 4))
        bezier2Path.line(to: NSPoint(x: icon.minX + 1, y: icon.minY + 3))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: icon.minX + 3, y: icon.minY + 3))
        bezier2Path.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 3))
        bezier2Path.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 4))
        bezier2Path.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 4))
        bezier2Path.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 3))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: icon.minX + 2, y: icon.minY + 4))
        bezier2Path.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 4))
        bezier2Path.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 5))
        bezier2Path.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 5))
        bezier2Path.line(to: NSPoint(x: icon.minX + 2, y: icon.minY + 4))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: icon.minX + 3, y: icon.minY + 5))
        bezier2Path.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 5))
        bezier2Path.line(to: NSPoint(x: icon.minX + 4, y: icon.minY + 6))
        bezier2Path.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 6))
        bezier2Path.line(to: NSPoint(x: icon.minX + 3, y: icon.minY + 5))
        bezier2Path.close()
        bezier2Path.windingRule = .evenOddWindingRule
        PalitraStyleKit.dark.setFill()
        bezier2Path.fill()
    }

    @objc dynamic public class func drawPalitraButton(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Rectangle Drawing
        let rectanglePath = NSBezierPath(roundedRect: NSRect(x: frame.minX + fastFloor(frame.width * 0.02083) + 0.5, y: frame.minY + fastFloor((frame.height - 0.5) * 0.02128) + 0.5, width: fastFloor(frame.width * 0.97917) - fastFloor(frame.width * 0.02083), height: frame.height - 1 - fastFloor((frame.height - 0.5) * 0.02128)), xRadius: 4, yRadius: 4)
        NSColor.black.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()
    }

    @objc dynamic public class func drawPaletteModeSegmentInactive(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let fillColor = NSColor(red: 0, green: 0, blue: 0, alpha: 1)


        //// Subframes
        let group: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 8) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 8, height: 12)


        //// Group
        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: group.minX + 4, y: group.minY))
        bezierPath.curve(to: NSPoint(x: group.minX, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX + 4, y: group.minY), controlPoint2: NSPoint(x: group.minX, y: group.minY + 5.6))
        bezierPath.curve(to: NSPoint(x: group.minX + 4, y: group.minY + 12), controlPoint1: NSPoint(x: group.minX, y: group.minY + 10.21), controlPoint2: NSPoint(x: group.minX + 1.79, y: group.minY + 12))
        bezierPath.curve(to: NSPoint(x: group.minX + 8, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX + 6.21, y: group.minY + 12), controlPoint2: NSPoint(x: group.minX + 8, y: group.minY + 10.21))
        bezierPath.curve(to: NSPoint(x: group.minX + 4, y: group.minY), controlPoint1: NSPoint(x: group.minX + 8, y: group.minY + 5.6), controlPoint2: NSPoint(x: group.minX + 4, y: group.minY))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 2, y: group.minY + 10))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 10))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 10))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 1, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 1, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 1, y: group.minY + 9))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 7))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 7))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 6))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 6))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        fillColor.setFill()
        bezierPath.fill()
    }

    @objc dynamic public class func drawPaletteModeSegmentActive(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let group: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 8) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 8, height: 12)


        //// Group
        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: group.minX + 4, y: group.minY))
        bezierPath.curve(to: NSPoint(x: group.minX, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX + 4, y: group.minY), controlPoint2: NSPoint(x: group.minX, y: group.minY + 5.6))
        bezierPath.curve(to: NSPoint(x: group.minX + 4, y: group.minY + 12), controlPoint1: NSPoint(x: group.minX, y: group.minY + 10.21), controlPoint2: NSPoint(x: group.minX + 1.79, y: group.minY + 12))
        bezierPath.curve(to: NSPoint(x: group.minX + 8, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX + 6.21, y: group.minY + 12), controlPoint2: NSPoint(x: group.minX + 8, y: group.minY + 10.21))
        bezierPath.curve(to: NSPoint(x: group.minX + 4, y: group.minY), controlPoint1: NSPoint(x: group.minX + 8, y: group.minY + 5.6), controlPoint2: NSPoint(x: group.minX + 4, y: group.minY))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 2, y: group.minY + 10))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 10))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 10))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 1, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 1, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 1, y: group.minY + 9))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 8))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 7))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 7))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 6))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 6))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        NSColor.white.setFill()
        bezierPath.fill()
    }

    @objc dynamic public class func drawSpecsModeSegmentInactive(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let fillColor = NSColor(red: 0, green: 0, blue: 0, alpha: 1)


        //// Subframes
        let group2: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 12, height: 12)


        //// Group 2
        //// Rectangle 4 Drawing
        let rectangle4Path = NSBezierPath(rect: NSRect(x: group2.minX + 2, y: group2.minY + 11, width: 8, height: 1))
        fillColor.setFill()
        rectangle4Path.fill()


        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: group2.minX + 5, y: group2.minY + 9))
        bezierPath.line(to: NSPoint(x: group2.minX + 7, y: group2.minY + 9))
        bezierPath.line(to: NSPoint(x: group2.minX + 8, y: group2.minY + 11))
        bezierPath.line(to: NSPoint(x: group2.minX + 4, y: group2.minY + 11))
        bezierPath.line(to: NSPoint(x: group2.minX + 5, y: group2.minY + 9))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        fillColor.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = NSBezierPath()
        bezier2Path.move(to: NSPoint(x: group2.minX + 11, y: group2.minY))
        bezier2Path.curve(to: NSPoint(x: group2.minX + 12, y: group2.minY + 1), controlPoint1: NSPoint(x: group2.minX + 11.55, y: group2.minY), controlPoint2: NSPoint(x: group2.minX + 12, y: group2.minY + 0.45))
        bezier2Path.line(to: NSPoint(x: group2.minX + 12, y: group2.minY + 8))
        bezier2Path.curve(to: NSPoint(x: group2.minX + 11, y: group2.minY + 9), controlPoint1: NSPoint(x: group2.minX + 12, y: group2.minY + 8.55), controlPoint2: NSPoint(x: group2.minX + 11.55, y: group2.minY + 9))
        bezier2Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 9))
        bezier2Path.curve(to: NSPoint(x: group2.minX, y: group2.minY + 8), controlPoint1: NSPoint(x: group2.minX + 0.45, y: group2.minY + 9), controlPoint2: NSPoint(x: group2.minX, y: group2.minY + 8.55))
        bezier2Path.line(to: NSPoint(x: group2.minX, y: group2.minY + 1))
        bezier2Path.curve(to: NSPoint(x: group2.minX + 1, y: group2.minY), controlPoint1: NSPoint(x: group2.minX, y: group2.minY + 0.45), controlPoint2: NSPoint(x: group2.minX + 0.45, y: group2.minY))
        bezier2Path.line(to: NSPoint(x: group2.minX + 11, y: group2.minY))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group2.minX + 1, y: group2.minY + 6))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 6))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 5))
        bezier2Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 5))
        bezier2Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 6))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group2.minX + 1, y: group2.minY + 4))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 4))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 3))
        bezier2Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 3))
        bezier2Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 4))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group2.minX + 2, y: group2.minY + 3))
        bezier2Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 3))
        bezier2Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 3))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group2.minX + 3, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 4, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 4, y: group2.minY + 1))
        bezier2Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 1))
        bezier2Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 2))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group2.minX + 1, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 1))
        bezier2Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 1))
        bezier2Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 2))
        bezier2Path.close()
        bezier2Path.windingRule = .evenOddWindingRule
        fillColor.setFill()
        bezier2Path.fill()
    }

    @objc dynamic public class func drawSpecsModeSegmentActive(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let group: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 12, height: 12)


        //// Group
        //// Rectangle 4 Drawing
        let rectangle4Path = NSBezierPath(rect: NSRect(x: group.minX + 2, y: group.minY + 11, width: 8, height: 1))
        NSColor.white.setFill()
        rectangle4Path.fill()


        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: group.minX + 5, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 7, y: group.minY + 9))
        bezierPath.line(to: NSPoint(x: group.minX + 8, y: group.minY + 11))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 11))
        bezierPath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 9))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        NSColor.white.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = NSBezierPath()
        bezier2Path.move(to: NSPoint(x: group.minX + 11, y: group.minY))
        bezier2Path.curve(to: NSPoint(x: group.minX + 12, y: group.minY + 1), controlPoint1: NSPoint(x: group.minX + 11.55, y: group.minY), controlPoint2: NSPoint(x: group.minX + 12, y: group.minY + 0.45))
        bezier2Path.line(to: NSPoint(x: group.minX + 12, y: group.minY + 8))
        bezier2Path.curve(to: NSPoint(x: group.minX + 11, y: group.minY + 9), controlPoint1: NSPoint(x: group.minX + 12, y: group.minY + 8.55), controlPoint2: NSPoint(x: group.minX + 11.55, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 1, y: group.minY + 9))
        bezier2Path.curve(to: NSPoint(x: group.minX, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX + 0.45, y: group.minY + 9), controlPoint2: NSPoint(x: group.minX, y: group.minY + 8.55))
        bezier2Path.line(to: NSPoint(x: group.minX, y: group.minY + 1))
        bezier2Path.curve(to: NSPoint(x: group.minX + 1, y: group.minY), controlPoint1: NSPoint(x: group.minX, y: group.minY + 0.45), controlPoint2: NSPoint(x: group.minX + 0.45, y: group.minY))
        bezier2Path.line(to: NSPoint(x: group.minX + 11, y: group.minY))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 1, y: group.minY + 6))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 6))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 5))
        bezier2Path.line(to: NSPoint(x: group.minX + 1, y: group.minY + 5))
        bezier2Path.line(to: NSPoint(x: group.minX + 1, y: group.minY + 6))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 1, y: group.minY + 4))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 4))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 3))
        bezier2Path.line(to: NSPoint(x: group.minX + 1, y: group.minY + 3))
        bezier2Path.line(to: NSPoint(x: group.minX + 1, y: group.minY + 4))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 2, y: group.minY + 3))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 3))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 2))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 2))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 3))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 3, y: group.minY + 2))
        bezier2Path.line(to: NSPoint(x: group.minX + 4, y: group.minY + 2))
        bezier2Path.line(to: NSPoint(x: group.minX + 4, y: group.minY + 1))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 1))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 2))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 1, y: group.minY + 2))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 2))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 1))
        bezier2Path.line(to: NSPoint(x: group.minX + 1, y: group.minY + 1))
        bezier2Path.line(to: NSPoint(x: group.minX + 1, y: group.minY + 2))
        bezier2Path.close()
        bezier2Path.windingRule = .evenOddWindingRule
        NSColor.white.setFill()
        bezier2Path.fill()
    }

    @objc dynamic public class func drawLibraryModeSegmentInactive(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Color Declarations
        let fillColor = NSColor(red: 0, green: 0, blue: 0, alpha: 1)


        //// Subframes
        let group2: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 12, height: 12)


        //// Group 2
        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: group2.minX + 11, y: group2.minY + 5))
        bezierPath.line(to: NSPoint(x: group2.minX + 10, y: group2.minY + 5))
        bezierPath.line(to: NSPoint(x: group2.minX + 10, y: group2.minY + 4))
        bezierPath.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 4))
        bezierPath.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 5))
        bezierPath.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 5))
        bezierPath.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 3))
        bezierPath.line(to: NSPoint(x: group2.minX + 11, y: group2.minY + 3))
        bezierPath.line(to: NSPoint(x: group2.minX + 11, y: group2.minY + 5))
        bezierPath.line(to: NSPoint(x: group2.minX + 11, y: group2.minY + 5))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        fillColor.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = NSBezierPath()
        bezier2Path.move(to: NSPoint(x: group2.minX + 10, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 9, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 9, y: group2.minY + 1))
        bezier2Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 1))
        bezier2Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY))
        bezier2Path.line(to: NSPoint(x: group2.minX + 10, y: group2.minY))
        bezier2Path.line(to: NSPoint(x: group2.minX + 10, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 10, y: group2.minY + 2))
        bezier2Path.close()
        bezier2Path.windingRule = .evenOddWindingRule
        fillColor.setFill()
        bezier2Path.fill()


        //// Bezier 3 Drawing
        let bezier3Path = NSBezierPath()
        bezier3Path.move(to: NSPoint(x: group2.minX, y: group2.minY + 12))
        bezier3Path.line(to: NSPoint(x: group2.minX + 12, y: group2.minY + 12))
        bezier3Path.line(to: NSPoint(x: group2.minX + 12, y: group2.minY + 6))
        bezier3Path.line(to: NSPoint(x: group2.minX, y: group2.minY + 6))
        bezier3Path.line(to: NSPoint(x: group2.minX, y: group2.minY + 12))
        bezier3Path.close()
        bezier3Path.move(to: NSPoint(x: group2.minX + 1, y: group2.minY + 10))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 10))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 9))
        bezier3Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 9))
        bezier3Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 10))
        bezier3Path.close()
        bezier3Path.move(to: NSPoint(x: group2.minX + 2, y: group2.minY + 9))
        bezier3Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 9))
        bezier3Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 9))
        bezier3Path.close()
        bezier3Path.move(to: NSPoint(x: group2.minX + 1, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 7))
        bezier3Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 7))
        bezier3Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 8))
        bezier3Path.close()
        bezier3Path.move(to: NSPoint(x: group2.minX + 3, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 4, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 4, y: group2.minY + 7))
        bezier3Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 7))
        bezier3Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 8))
        bezier3Path.close()
        bezier3Path.windingRule = .evenOddWindingRule
        fillColor.setFill()
        bezier3Path.fill()
    }

    @objc dynamic public class func drawLibraryModeSegmentActive(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let group2: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 12, height: 12)


        //// Group 2
        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: group2.minX + 11, y: group2.minY + 5))
        bezierPath.line(to: NSPoint(x: group2.minX + 10, y: group2.minY + 5))
        bezierPath.line(to: NSPoint(x: group2.minX + 10, y: group2.minY + 4))
        bezierPath.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 4))
        bezierPath.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 5))
        bezierPath.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 5))
        bezierPath.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 3))
        bezierPath.line(to: NSPoint(x: group2.minX + 11, y: group2.minY + 3))
        bezierPath.line(to: NSPoint(x: group2.minX + 11, y: group2.minY + 5))
        bezierPath.line(to: NSPoint(x: group2.minX + 11, y: group2.minY + 5))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        NSColor.white.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = NSBezierPath()
        bezier2Path.move(to: NSPoint(x: group2.minX + 10, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 9, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 9, y: group2.minY + 1))
        bezier2Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 1))
        bezier2Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY))
        bezier2Path.line(to: NSPoint(x: group2.minX + 10, y: group2.minY))
        bezier2Path.line(to: NSPoint(x: group2.minX + 10, y: group2.minY + 2))
        bezier2Path.line(to: NSPoint(x: group2.minX + 10, y: group2.minY + 2))
        bezier2Path.close()
        bezier2Path.windingRule = .evenOddWindingRule
        NSColor.white.setFill()
        bezier2Path.fill()


        //// Bezier 3 Drawing
        let bezier3Path = NSBezierPath()
        bezier3Path.move(to: NSPoint(x: group2.minX, y: group2.minY + 12))
        bezier3Path.line(to: NSPoint(x: group2.minX + 12, y: group2.minY + 12))
        bezier3Path.line(to: NSPoint(x: group2.minX + 12, y: group2.minY + 6))
        bezier3Path.line(to: NSPoint(x: group2.minX, y: group2.minY + 6))
        bezier3Path.line(to: NSPoint(x: group2.minX, y: group2.minY + 12))
        bezier3Path.close()
        bezier3Path.move(to: NSPoint(x: group2.minX + 1, y: group2.minY + 10))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 10))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 9))
        bezier3Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 9))
        bezier3Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 10))
        bezier3Path.close()
        bezier3Path.move(to: NSPoint(x: group2.minX + 2, y: group2.minY + 9))
        bezier3Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 9))
        bezier3Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 9))
        bezier3Path.close()
        bezier3Path.move(to: NSPoint(x: group2.minX + 1, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 2, y: group2.minY + 7))
        bezier3Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 7))
        bezier3Path.line(to: NSPoint(x: group2.minX + 1, y: group2.minY + 8))
        bezier3Path.close()
        bezier3Path.move(to: NSPoint(x: group2.minX + 3, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 4, y: group2.minY + 8))
        bezier3Path.line(to: NSPoint(x: group2.minX + 4, y: group2.minY + 7))
        bezier3Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 7))
        bezier3Path.line(to: NSPoint(x: group2.minX + 3, y: group2.minY + 8))
        bezier3Path.close()
        bezier3Path.windingRule = .evenOddWindingRule
        NSColor.white.setFill()
        bezier3Path.fill()
    }

    @objc dynamic public class func drawPalitraNewButtonActive(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let group: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 12, height: 12)


        //// Rectangle Drawing
        let rectanglePath = NSBezierPath(roundedRect: NSRect(x: frame.minX + fastFloor(frame.width * 0.02083) + 0.5, y: frame.minY + fastFloor(frame.height * 0.02083) + 0.5, width: fastFloor(frame.width * 0.97917) - fastFloor(frame.width * 0.02083), height: fastFloor(frame.height * 0.97917) - fastFloor(frame.height * 0.02083)), xRadius: 4, yRadius: 4)
        PalitraStyleKit.dark.setFill()
        rectanglePath.fill()
        NSColor.black.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()


        //// Group
        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: group.minX + 6, y: group.minY + 3))
        bezierPath.curve(to: NSPoint(x: group.minX + 7, y: group.minY + 2), controlPoint1: NSPoint(x: group.minX + 6, y: group.minY + 2.45), controlPoint2: NSPoint(x: group.minX + 6.45, y: group.minY + 2))
        bezierPath.line(to: NSPoint(x: group.minX + 8, y: group.minY + 2))
        bezierPath.line(to: NSPoint(x: group.minX + 8, y: group.minY + 1))
        bezierPath.curve(to: NSPoint(x: group.minX + 9, y: group.minY), controlPoint1: NSPoint(x: group.minX + 8, y: group.minY + 0.45), controlPoint2: NSPoint(x: group.minX + 8.45, y: group.minY))
        bezierPath.curve(to: NSPoint(x: group.minX + 10, y: group.minY + 1), controlPoint1: NSPoint(x: group.minX + 9.55, y: group.minY), controlPoint2: NSPoint(x: group.minX + 10, y: group.minY + 0.45))
        bezierPath.line(to: NSPoint(x: group.minX + 10, y: group.minY + 2))
        bezierPath.line(to: NSPoint(x: group.minX + 11, y: group.minY + 2))
        bezierPath.curve(to: NSPoint(x: group.minX + 11.71, y: group.minY + 2.29), controlPoint1: NSPoint(x: group.minX + 11.27, y: group.minY + 2), controlPoint2: NSPoint(x: group.minX + 11.52, y: group.minY + 2.11))
        bezierPath.curve(to: NSPoint(x: group.minX + 12, y: group.minY + 3), controlPoint1: NSPoint(x: group.minX + 11.89, y: group.minY + 2.48), controlPoint2: NSPoint(x: group.minX + 12, y: group.minY + 2.73))
        bezierPath.curve(to: NSPoint(x: group.minX + 11, y: group.minY + 4), controlPoint1: NSPoint(x: group.minX + 12, y: group.minY + 3.55), controlPoint2: NSPoint(x: group.minX + 11.55, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 10, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 10, y: group.minY + 5))
        bezierPath.curve(to: NSPoint(x: group.minX + 9, y: group.minY + 6), controlPoint1: NSPoint(x: group.minX + 10, y: group.minY + 5.55), controlPoint2: NSPoint(x: group.minX + 9.55, y: group.minY + 6))
        bezierPath.curve(to: NSPoint(x: group.minX + 8, y: group.minY + 5), controlPoint1: NSPoint(x: group.minX + 8.45, y: group.minY + 6), controlPoint2: NSPoint(x: group.minX + 8, y: group.minY + 5.55))
        bezierPath.line(to: NSPoint(x: group.minX + 8, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 7, y: group.minY + 4))
        bezierPath.curve(to: NSPoint(x: group.minX + 6, y: group.minY + 3), controlPoint1: NSPoint(x: group.minX + 6.45, y: group.minY + 4), controlPoint2: NSPoint(x: group.minX + 6, y: group.minY + 3.55))
        bezierPath.line(to: NSPoint(x: group.minX + 6, y: group.minY + 3))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        NSColor.white.setFill()
        bezierPath.fill()


        //// Bezier 2 Drawing
        let bezier2Path = NSBezierPath()
        bezier2Path.move(to: NSPoint(x: group.minX + 7.68, y: group.minY + 6.5))
        bezier2Path.curve(to: NSPoint(x: group.minX + 8, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX + 7.88, y: group.minY + 7.07), controlPoint2: NSPoint(x: group.minX + 8, y: group.minY + 7.58))
        bezier2Path.curve(to: NSPoint(x: group.minX + 4, y: group.minY + 12), controlPoint1: NSPoint(x: group.minX + 8, y: group.minY + 10.21), controlPoint2: NSPoint(x: group.minX + 6.21, y: group.minY + 12))
        bezier2Path.curve(to: NSPoint(x: group.minX, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX + 1.79, y: group.minY + 12), controlPoint2: NSPoint(x: group.minX, y: group.minY + 10.21))
        bezier2Path.curve(to: NSPoint(x: group.minX + 4, y: group.minY), controlPoint1: NSPoint(x: group.minX, y: group.minY + 5.6), controlPoint2: NSPoint(x: group.minX + 4, y: group.minY))
        bezier2Path.curve(to: NSPoint(x: group.minX + 5.3, y: group.minY + 1.95), controlPoint1: NSPoint(x: group.minX + 4, y: group.minY), controlPoint2: NSPoint(x: group.minX + 4.58, y: group.minY + 0.81))
        bezier2Path.curve(to: NSPoint(x: group.minX + 5.2, y: group.minY + 2.13), controlPoint1: NSPoint(x: group.minX + 5.26, y: group.minY + 2.01), controlPoint2: NSPoint(x: group.minX + 5.23, y: group.minY + 2.07))
        bezier2Path.curve(to: NSPoint(x: group.minX + 5.09, y: group.minY + 3.59), controlPoint1: NSPoint(x: group.minX + 4.98, y: group.minY + 2.59), controlPoint2: NSPoint(x: group.minX + 4.94, y: group.minY + 3.11))
        bezier2Path.curve(to: NSPoint(x: group.minX + 5.4, y: group.minY + 4.2), controlPoint1: NSPoint(x: group.minX + 5.16, y: group.minY + 3.81), controlPoint2: NSPoint(x: group.minX + 5.26, y: group.minY + 4.02))
        bezier2Path.curve(to: NSPoint(x: group.minX + 5.96, y: group.minY + 4.71), controlPoint1: NSPoint(x: group.minX + 5.55, y: group.minY + 4.4), controlPoint2: NSPoint(x: group.minX + 5.74, y: group.minY + 4.58))
        bezier2Path.curve(to: NSPoint(x: group.minX + 6.5, y: group.minY + 4.94), controlPoint1: NSPoint(x: group.minX + 6.13, y: group.minY + 4.81), controlPoint2: NSPoint(x: group.minX + 6.31, y: group.minY + 4.89))
        bezier2Path.curve(to: NSPoint(x: group.minX + 6.8, y: group.minY + 4.99), controlPoint1: NSPoint(x: group.minX + 6.6, y: group.minY + 4.96), controlPoint2: NSPoint(x: group.minX + 6.7, y: group.minY + 4.98))
        bezier2Path.line(to: NSPoint(x: group.minX + 6.9, y: group.minY + 5))
        bezier2Path.curve(to: NSPoint(x: group.minX + 7, y: group.minY + 5), controlPoint1: NSPoint(x: group.minX + 6.93, y: group.minY + 5), controlPoint2: NSPoint(x: group.minX + 6.97, y: group.minY + 5))
        bezier2Path.line(to: NSPoint(x: group.minX + 7, y: group.minY + 5.01))
        bezier2Path.curve(to: NSPoint(x: group.minX + 7.02, y: group.minY + 5.3), controlPoint1: NSPoint(x: group.minX + 7, y: group.minY + 5.11), controlPoint2: NSPoint(x: group.minX + 7.01, y: group.minY + 5.21))
        bezier2Path.curve(to: NSPoint(x: group.minX + 7.24, y: group.minY + 5.95), controlPoint1: NSPoint(x: group.minX + 7.06, y: group.minY + 5.53), controlPoint2: NSPoint(x: group.minX + 7.13, y: group.minY + 5.75))
        bezier2Path.curve(to: NSPoint(x: group.minX + 7.68, y: group.minY + 6.5), controlPoint1: NSPoint(x: group.minX + 7.35, y: group.minY + 6.16), controlPoint2: NSPoint(x: group.minX + 7.5, y: group.minY + 6.35))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 2, y: group.minY + 10))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 10))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 10))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 1, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 1, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 1, y: group.minY + 9))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 4, y: group.minY + 9))
        bezier2Path.line(to: NSPoint(x: group.minX + 4, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 9))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 8))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 7))
        bezier2Path.line(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        bezier2Path.close()
        bezier2Path.move(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezier2Path.line(to: NSPoint(x: group.minX + 4, y: group.minY + 7))
        bezier2Path.line(to: NSPoint(x: group.minX + 4, y: group.minY + 6))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 6))
        bezier2Path.line(to: NSPoint(x: group.minX + 3, y: group.minY + 7))
        bezier2Path.close()
        bezier2Path.windingRule = .evenOddWindingRule
        NSColor.white.setFill()
        bezier2Path.fill()
    }

    @objc dynamic public class func drawPalitraRandomizeButtonActive(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let group: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 12, height: 12)


        //// Rectangle Drawing
        let rectanglePath = NSBezierPath(roundedRect: NSRect(x: frame.minX + fastFloor(frame.width * 0.02083) + 0.5, y: frame.minY + 0.5, width: fastFloor(frame.width * 0.97917) - fastFloor(frame.width * 0.02083), height: fastFloor((frame.height - 0.5) * 0.97872 + 0.5)), xRadius: 4, yRadius: 4)
        PalitraStyleKit.dark.setFill()
        rectanglePath.fill()
        NSColor.black.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()


        //// Group
        //// shape Drawing
        let shapePath = NSBezierPath()
        shapePath.move(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        shapePath.curve(to: NSPoint(x: group.minX + 4, y: group.minY + 10), controlPoint1: NSPoint(x: group.minX + 3.1, y: group.minY + 8), controlPoint2: NSPoint(x: group.minX + 4, y: group.minY + 8.9))
        shapePath.curve(to: NSPoint(x: group.minX + 2, y: group.minY + 12), controlPoint1: NSPoint(x: group.minX + 4, y: group.minY + 11.1), controlPoint2: NSPoint(x: group.minX + 3.1, y: group.minY + 12))
        shapePath.curve(to: NSPoint(x: group.minX, y: group.minY + 10), controlPoint1: NSPoint(x: group.minX + 0.9, y: group.minY + 12), controlPoint2: NSPoint(x: group.minX, y: group.minY + 11.1))
        shapePath.curve(to: NSPoint(x: group.minX + 2, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX, y: group.minY + 8.9), controlPoint2: NSPoint(x: group.minX + 0.9, y: group.minY + 8))
        shapePath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 8))
        shapePath.close()
        shapePath.move(to: NSPoint(x: group.minX + 1, y: group.minY + 10))
        shapePath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 10))
        shapePath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 9))
        shapePath.line(to: NSPoint(x: group.minX + 1, y: group.minY + 9))
        shapePath.line(to: NSPoint(x: group.minX + 1, y: group.minY + 10))
        shapePath.close()
        shapePath.move(to: NSPoint(x: group.minX + 6, y: group.minY + 4))
        shapePath.curve(to: NSPoint(x: group.minX + 8, y: group.minY + 6), controlPoint1: NSPoint(x: group.minX + 7.1, y: group.minY + 4), controlPoint2: NSPoint(x: group.minX + 8, y: group.minY + 4.9))
        shapePath.curve(to: NSPoint(x: group.minX + 6, y: group.minY + 8), controlPoint1: NSPoint(x: group.minX + 8, y: group.minY + 7.1), controlPoint2: NSPoint(x: group.minX + 7.1, y: group.minY + 8))
        shapePath.curve(to: NSPoint(x: group.minX + 4, y: group.minY + 6), controlPoint1: NSPoint(x: group.minX + 4.9, y: group.minY + 8), controlPoint2: NSPoint(x: group.minX + 4, y: group.minY + 7.1))
        shapePath.curve(to: NSPoint(x: group.minX + 6, y: group.minY + 4), controlPoint1: NSPoint(x: group.minX + 4, y: group.minY + 4.9), controlPoint2: NSPoint(x: group.minX + 4.9, y: group.minY + 4))
        shapePath.line(to: NSPoint(x: group.minX + 6, y: group.minY + 4))
        shapePath.close()
        shapePath.move(to: NSPoint(x: group.minX + 5, y: group.minY + 6))
        shapePath.line(to: NSPoint(x: group.minX + 6, y: group.minY + 6))
        shapePath.line(to: NSPoint(x: group.minX + 6, y: group.minY + 5))
        shapePath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 5))
        shapePath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 6))
        shapePath.close()
        shapePath.move(to: NSPoint(x: group.minX + 10, y: group.minY))
        shapePath.curve(to: NSPoint(x: group.minX + 12, y: group.minY + 2), controlPoint1: NSPoint(x: group.minX + 11.1, y: group.minY), controlPoint2: NSPoint(x: group.minX + 12, y: group.minY + 0.9))
        shapePath.curve(to: NSPoint(x: group.minX + 10, y: group.minY + 4), controlPoint1: NSPoint(x: group.minX + 12, y: group.minY + 3.1), controlPoint2: NSPoint(x: group.minX + 11.1, y: group.minY + 4))
        shapePath.curve(to: NSPoint(x: group.minX + 8, y: group.minY + 2), controlPoint1: NSPoint(x: group.minX + 8.9, y: group.minY + 4), controlPoint2: NSPoint(x: group.minX + 8, y: group.minY + 3.1))
        shapePath.curve(to: NSPoint(x: group.minX + 10, y: group.minY), controlPoint1: NSPoint(x: group.minX + 8, y: group.minY + 0.9), controlPoint2: NSPoint(x: group.minX + 8.9, y: group.minY))
        shapePath.line(to: NSPoint(x: group.minX + 10, y: group.minY))
        shapePath.close()
        shapePath.move(to: NSPoint(x: group.minX + 9, y: group.minY + 2))
        shapePath.line(to: NSPoint(x: group.minX + 10, y: group.minY + 2))
        shapePath.line(to: NSPoint(x: group.minX + 10, y: group.minY + 1))
        shapePath.line(to: NSPoint(x: group.minX + 9, y: group.minY + 1))
        shapePath.line(to: NSPoint(x: group.minX + 9, y: group.minY + 2))
        shapePath.close()
        shapePath.windingRule = .evenOddWindingRule
        NSColor.white.setFill()
        shapePath.fill()
    }

    @objc dynamic public class func drawPalitraSketchSyncButtonActive(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let group: NSRect = NSRect(x: frame.minX + fastFloor((frame.width - 12) * 0.50000 + 0.5), y: frame.minY + fastFloor((frame.height - 12) * 0.50000 + 0.5), width: 12, height: 12)


        //// Rectangle Drawing
        let rectanglePath = NSBezierPath(roundedRect: NSRect(x: frame.minX + fastFloor(frame.width * 0.02083) + 0.5, y: frame.minY + 0.5, width: fastFloor(frame.width * 0.97917) - fastFloor(frame.width * 0.02083), height: fastFloor((frame.height - 0.5) * 0.97872 + 0.5)), xRadius: 4, yRadius: 4)
        PalitraStyleKit.dark.setFill()
        rectanglePath.fill()
        NSColor.black.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()


        //// Group
        //// Bezier Drawing
        let bezierPath = NSBezierPath()
        bezierPath.move(to: NSPoint(x: group.minX + 2, y: group.minY))
        bezierPath.line(to: NSPoint(x: group.minX + 10, y: group.minY))
        bezierPath.line(to: NSPoint(x: group.minX + 12, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 12, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 6, y: group.minY + 12))
        bezierPath.line(to: NSPoint(x: group.minX, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 4, y: group.minY + 6))
        bezierPath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 6))
        bezierPath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 5))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 5))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 6))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 3, y: group.minY + 5))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 5))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 5))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 2, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 2, y: group.minY + 4))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 4, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 4))
        bezierPath.line(to: NSPoint(x: group.minX + 5, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 4))
        bezierPath.close()
        bezierPath.move(to: NSPoint(x: group.minX + 3, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 3))
        bezierPath.line(to: NSPoint(x: group.minX + 4, y: group.minY + 2))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 2))
        bezierPath.line(to: NSPoint(x: group.minX + 3, y: group.minY + 3))
        bezierPath.close()
        bezierPath.windingRule = .evenOddWindingRule
        NSColor.white.setFill()
        bezierPath.fill()
    }

    @objc dynamic public class func drawSectionViewWithTopSeparator(frame: NSRect = NSRect(x: 0, y: 0, width: 128, height: 84)) {
        //// General Declarations
        let context = NSGraphicsContext.current!.cgContext
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Shadow Declarations
        let topSeparatorShadow = NSShadow()
        topSeparatorShadow.shadowColor = PalitraStyleKit.lightGrey
        topSeparatorShadow.shadowOffset = NSSize(width: 0, height: -1)
        topSeparatorShadow.shadowBlurRadius = 0

        //// Rectangle Drawing
        let rectanglePath = NSBezierPath(rect: NSRect(x: frame.minX + fastFloor(frame.width * -0.00000 - 0.5) + 1, y: frame.minY + fastFloor(frame.height * 0.00000 + 0.5), width: fastFloor(frame.width * 1.00000 - 0.5) - fastFloor(frame.width * -0.00000 - 0.5), height: fastFloor(frame.height * 1.00000 + 0.5) - fastFloor(frame.height * 0.00000 + 0.5)))
        PalitraStyleKit.paleWhite.setFill()
        rectanglePath.fill()

        ////// Rectangle Inner Shadow
        NSGraphicsContext.saveGraphicsState()
        rectanglePath.bounds.clip()
        context.setShadow(offset: NSSize.zero, blur: 0, color: nil)

        context.setAlpha(topSeparatorShadow.shadowColor!.alphaComponent)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        let rectangleOpaqueShadow = NSShadow()
        rectangleOpaqueShadow.shadowColor = topSeparatorShadow.shadowColor!.withAlphaComponent(1)
        rectangleOpaqueShadow.shadowOffset = topSeparatorShadow.shadowOffset
        rectangleOpaqueShadow.shadowBlurRadius = topSeparatorShadow.shadowBlurRadius
        rectangleOpaqueShadow.set()

        context.setBlendMode(.sourceOut)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        rectangleOpaqueShadow.shadowColor!.setFill()
        rectanglePath.fill()

        context.endTransparencyLayer()
        context.endTransparencyLayer()
        NSGraphicsContext.restoreGraphicsState()
    }

    @objc dynamic public class func drawSectionViewWithBottomSeparator(frame: NSRect = NSRect(x: 0, y: 0, width: 128, height: 84)) {
        //// General Declarations
        let context = NSGraphicsContext.current!.cgContext
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Shadow Declarations
        let botSeparatorShadow = NSShadow()
        botSeparatorShadow.shadowColor = PalitraStyleKit.lightGrey
        botSeparatorShadow.shadowOffset = NSSize(width: 0, height: 1)
        botSeparatorShadow.shadowBlurRadius = 0

        //// Rectangle Drawing
        let rectanglePath = NSBezierPath(rect: NSRect(x: frame.minX + fastFloor(frame.width * 0.00000 + 0.5), y: frame.minY + fastFloor(frame.height * 0.00000 + 0.5), width: fastFloor(frame.width * 1.00000 + 0.5) - fastFloor(frame.width * 0.00000 + 0.5), height: fastFloor(frame.height * 1.00000 + 0.5) - fastFloor(frame.height * 0.00000 + 0.5)))
        PalitraStyleKit.paleWhite.setFill()
        rectanglePath.fill()

        ////// Rectangle Inner Shadow
        NSGraphicsContext.saveGraphicsState()
        rectanglePath.bounds.clip()
        context.setShadow(offset: NSSize.zero, blur: 0, color: nil)

        context.setAlpha(botSeparatorShadow.shadowColor!.alphaComponent)
        context.beginTransparencyLayer(auxiliaryInfo: nil)
        let rectangleOpaqueShadow = NSShadow()
        rectangleOpaqueShadow.shadowColor = botSeparatorShadow.shadowColor!.withAlphaComponent(1)
        rectangleOpaqueShadow.shadowOffset = botSeparatorShadow.shadowOffset
        rectangleOpaqueShadow.shadowBlurRadius = botSeparatorShadow.shadowBlurRadius
        rectangleOpaqueShadow.set()

        context.setBlendMode(.sourceOut)
        context.beginTransparencyLayer(auxiliaryInfo: nil)

        rectangleOpaqueShadow.shadowColor!.setFill()
        rectanglePath.fill()

        context.endTransparencyLayer()
        context.endTransparencyLayer()
        NSGraphicsContext.restoreGraphicsState()
    }

    @objc dynamic public class func drawColorPickerCrosshair(frame targetFrame: NSRect = NSRect(x: 0, y: 0, width: 15, height: 15), resizing: ResizingBehavior = .aspectFit, crossHairPosition: NSPoint = NSPoint(x: 1, y: 1)) {
        //// General Declarations
        let context = NSGraphicsContext.current!.cgContext
        
        //// Resize to Target Frame
        NSGraphicsContext.saveGraphicsState()
        let resizedFrame: NSRect = resizing.apply(rect: NSRect(x: 0, y: 0, width: 15, height: 15), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 15, y: resizedFrame.height / 15)


        //// Group
        NSGraphicsContext.saveGraphicsState()
        context.translateBy(x: crossHairPosition.x, y: crossHairPosition.y)



        //// Oval Drawing
        let ovalPath = NSBezierPath(ovalIn: NSRect(x: 0, y: 0, width: 13, height: 13))
        PalitraStyleKit.paleWhite.setStroke()
        ovalPath.lineWidth = 1
        ovalPath.stroke()


        //// Oval 2 Drawing
        let oval2Path = NSBezierPath(ovalIn: NSRect(x: 1, y: 1, width: 11, height: 11))
        PalitraStyleKit.dark.setStroke()
        oval2Path.lineWidth = 1
        oval2Path.stroke()


        //// Rectangle Drawing
        let rectanglePath = NSBezierPath(rect: NSRect(x: 6, y: 8, width: 1, height: 3))
        PalitraStyleKit.paleWhite.setFill()
        rectanglePath.fill()


        //// Rectangle 2 Drawing
        let rectangle2Path = NSBezierPath(rect: NSRect(x: 6, y: 2, width: 1, height: 3))
        PalitraStyleKit.paleWhite.setFill()
        rectangle2Path.fill()


        //// Rectangle 3 Drawing
        NSGraphicsContext.saveGraphicsState()
        context.translateBy(x: 3.5, y: 6.5)
        context.rotate(by: 90 * CGFloat.pi/180)

        let rectangle3Path = NSBezierPath(rect: NSRect(x: -0.5, y: -1.5, width: 1, height: 3))
        PalitraStyleKit.paleWhite.setFill()
        rectangle3Path.fill()

        NSGraphicsContext.restoreGraphicsState()


        //// Rectangle 4 Drawing
        NSGraphicsContext.saveGraphicsState()
        context.translateBy(x: 9.5, y: 6.5)
        context.rotate(by: 90 * CGFloat.pi/180)

        let rectangle4Path = NSBezierPath(rect: NSRect(x: -0.5, y: -1.5, width: 1, height: 3))
        PalitraStyleKit.paleWhite.setFill()
        rectangle4Path.fill()

        NSGraphicsContext.restoreGraphicsState()



        NSGraphicsContext.restoreGraphicsState()
        
        NSGraphicsContext.restoreGraphicsState()

    }

    @objc dynamic public class func drawHueSelector(frame targetFrame: NSRect = NSRect(x: 0, y: 0, width: 14, height: 32), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = NSGraphicsContext.current!.cgContext
        
        //// Resize to Target Frame
        NSGraphicsContext.saveGraphicsState()
        let resizedFrame: NSRect = resizing.apply(rect: NSRect(x: 0, y: 0, width: 14, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 14, y: resizedFrame.height / 32)
        let resizedShadowScale: CGFloat = min(resizedFrame.width / 14, resizedFrame.height / 32)


        //// Color Declarations
        let fillColor2 = NSColor(red: 1, green: 1, blue: 1, alpha: 1)

        //// Shadow Declarations
        let botShadow2px = NSShadow()
        botShadow2px.shadowColor = NSColor.black.withAlphaComponent(0.19)
        botShadow2px.shadowOffset = NSSize(width: 0, height: -2)
        botShadow2px.shadowBlurRadius = 2
        let topShadow2px = NSShadow()
        topShadow2px.shadowColor = NSColor.black.withAlphaComponent(0.2)
        topShadow2px.shadowOffset = NSSize(width: 0, height: 2)
        topShadow2px.shadowBlurRadius = 2

        //// Group 2
        //// shadowShape Drawing
        let shadowShapePath = NSBezierPath(roundedRect: NSRect(x: 3, y: 4, width: 8, height: 24), xRadius: 4, yRadius: 4)
        NSGraphicsContext.saveGraphicsState()
        context.setShadow(offset: NSSize(width: topShadow2px.shadowOffset.width * resizedShadowScale, height: topShadow2px.shadowOffset.height * resizedShadowScale), blur: topShadow2px.shadowBlurRadius * resizedShadowScale, color: topShadow2px.shadowColor!.cgColor)
        fillColor2.setFill()
        shadowShapePath.fill()
        NSGraphicsContext.restoreGraphicsState()



        //// masterShape Drawing
        let masterShapePath = NSBezierPath(roundedRect: NSRect(x: 3, y: 4, width: 8, height: 24), xRadius: 4, yRadius: 4)
        NSGraphicsContext.saveGraphicsState()
        context.setShadow(offset: NSSize(width: botShadow2px.shadowOffset.width * resizedShadowScale, height: botShadow2px.shadowOffset.height * resizedShadowScale), blur: botShadow2px.shadowBlurRadius * resizedShadowScale, color: botShadow2px.shadowColor!.cgColor)
        fillColor2.setFill()
        masterShapePath.fill()
        NSGraphicsContext.restoreGraphicsState()
        
        NSGraphicsContext.restoreGraphicsState()

    }

    @objc dynamic public class func drawPalitraButtonDark(frame: NSRect = NSRect(x: 0, y: 0, width: 24, height: 24)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }

        //// Rectangle Drawing
        let rectanglePath = NSBezierPath(roundedRect: NSRect(x: frame.minX + fastFloor(frame.width * 0.02083) + 0.5, y: frame.minY + fastFloor((frame.height - 0.5) * 0.02128) + 0.5, width: fastFloor(frame.width * 0.97917) - fastFloor(frame.width * 0.02083), height: frame.height - 1 - fastFloor((frame.height - 0.5) * 0.02128)), xRadius: 4, yRadius: 4)
        PalitraStyleKit.dark.setFill()
        rectanglePath.fill()
        NSColor.black.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()
    }

    //// Generated Images

    @objc dynamic public class func imageOfPalitraNewButton(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawPalitraNewButton(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfPalitraRandomizeButton(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawPalitraRandomizeButton(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfPalitraSketchSyncButton(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawPalitraSketchSyncButton(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfSketchIcon(imageSize: NSSize = NSSize(width: 12, height: 12)) -> NSImage {
        return NSImage(size: imageSize, flipped: false) { _ in 
            PalitraStyleKit.drawSketchIcon(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfRandomizeIcon(imageSize: NSSize = NSSize(width: 12, height: 12)) -> NSImage {
        return NSImage(size: imageSize, flipped: false) { _ in 
            PalitraStyleKit.drawRandomizeIcon(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfPaletteIcon(imageSize: NSSize = NSSize(width: 12, height: 12)) -> NSImage {
        return NSImage(size: imageSize, flipped: false) { _ in 
            PalitraStyleKit.drawPaletteIcon(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfPalitraButton(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: false) { _ in 
            PalitraStyleKit.drawPalitraButton(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfPaletteModeSegmentInactive(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawPaletteModeSegmentInactive(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfPaletteModeSegmentActive(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawPaletteModeSegmentActive(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfSpecsModeSegmentInactive(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawSpecsModeSegmentInactive(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfSpecsModeSegmentActive(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawSpecsModeSegmentActive(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfLibraryModeSegmentInactive(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawLibraryModeSegmentInactive(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfLibraryModeSegmentActive(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawLibraryModeSegmentActive(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfPalitraNewButtonActive(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawPalitraNewButtonActive(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfPalitraRandomizeButtonActive(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawPalitraRandomizeButtonActive(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfPalitraSketchSyncButtonActive(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: true) { _ in 
            PalitraStyleKit.drawPalitraSketchSyncButtonActive(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }

    @objc dynamic public class func imageOfPalitraButtonDark(imageSize: NSSize = NSSize(width: 24, height: 24)) -> NSImage {
        return NSImage(size: imageSize, flipped: false) { _ in 
            PalitraStyleKit.drawPalitraButtonDark(frame: NSRect(x: 0, y: 0, width: imageSize.width, height: imageSize.height))

            return true
        }
    }




    @objc(PalitraStyleKitResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: NSRect, target: NSRect) -> NSRect {
            if rect == target || target == NSRect.zero {
                return rect
            }

            var scales = NSSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}
